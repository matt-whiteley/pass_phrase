#!/usr/bin/env ruby

# bin/pass_phrase

# This loads the logic from lib/pass_phrase.rb
require 'pass_phrase'
require 'optparse'

# Default options
options = {
  num: 1,
  separator: ' ',
  min_length: 0,
  max_length: 20,
  valid_chars: '.',
  uppercase: false,
  lowercase: false,
  capitalise: false,
  make_leet: false,
  make_mini_leet: false,
  verbose: false
}

# Create the option parser
parser = OptionParser.new do |opts|
  opts.banner = "Usage: pass_phrase [options]"

  opts.on("--adjectives FILE", "List of valid adjectives for passphrase") do |file|
    options[:adjectives] = file
  end
  opts.on("--nouns FILE", "List of valid nouns for passphrase") do |file|
    options[:nouns] = file
  end
  opts.on("--verbs FILE", "List of valid verbs for passphrase") do |file|
    options[:verbs] = file
  end
  
  opts.on("-s", "--separator SEP", "Separator to add between words (default: ' ')") do |sep|
    options[:separator] = sep
  end
  opts.on("-n", "--num NUM", Integer, "Number of passphrases to generate (default: 1)") do |n|
    options[:num] = n
  end

  opts.on("--min LEN", Integer, "Minimum length of a valid word (default: 0)") do |len|
    options[:min_length] = len
  end
  opts.on("--max LEN", Integer, "Maximum length of a valid word (default: 20)") do |len|
    options[:max_length] = len
  end
  
  opts.on("--valid_chars REGEX", "Valid chars, using regex style (e.g. '[a-z]')") do |regex|
    options[:valid_chars] = regex
  end

  opts.on("-U", "--uppercase", "Force passphrase into uppercase") do
    options[:uppercase] = true
  end
  opts.on("-L", "--lowercase", "Force passphrase into lowercase") do
    options[:lowercase] = true
  end
  opts.on("-C", "--capitalise", "--capitalize", "Force passphrase to capitalise each word") do
    options[:capitalise] = true
  end
  
  opts.on("--l337", "Enable full l33t speak") do
    options[:make_leet] = true
  end
  opts.on("--l337ish", "Enable mini-l33t speak (easier to read)") do
    options[:make_mini_leet] = true
  end

  opts.on("-V", "--verbose", "Report various metrics for given options") do
    options[:verbose] = true
  end
  
  opts.on("-h", "--help", "Show this help message") do
    puts opts
    exit
  end
end

begin
  # --- Main Execution ---

  # 1. Parse arguments!
  args = parser.parse!(ARGV)

  # 2. Validate options (this can now raise PassPhrase::Error)
  PassPhrase::Generator.validate_options(options, args)

  # 3. Generate word lists (this can now raise PassPhrase::Error)
  adjectives = PassPhrase::Generator.generate_wordlist(
    wordfile: options[:adjectives],
    # ... other options
  )
  nouns = PassPhrase::Generator.generate_wordlist(
    wordfile: options[:nouns],
    # ... other options
  )
  verbs = PassPhrase::Generator.generate_wordlist(
    wordfile: options[:verbs],
    # ... other options
  )

  # 4. Run verbose reports if requested
  if options[:verbose]
    PassPhrase::Generator.verbose_reports(
      adjectives: adjectives,
      nouns: nouns,
      verbs: verbs,
      options: options
    )
  end

  # 5. Generate and print the passphrase(s)
  puts PassPhrase::Generator.passphrase(
    adjectives, nouns, verbs, options
  )

# --- Error Handling ---
rescue OptionParser::InvalidOption => e
  # Handle bad command-line flags
  warn "Error: #{e.message}"
  warn parser # Print help
  exit(1)
rescue PassPhrase::Error => e
  # Handle all our custom library errors
  warn e.message
  exit(1)
rescue StandardError => e
  # Handle any other unexpected error
  warn "An unexpected error occurred: #{e.message}"
  warn e.backtrace.join("\n")
  exit(1)
end
